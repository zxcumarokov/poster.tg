import threading
from _typeshed import Incomplete
from telebot import types
from telebot.service_utils import chunks as chunks, generate_random_token as generate_random_token, is_bytes as is_bytes, is_dict as is_dict, is_pil_image as is_pil_image, is_string as is_string, pil_image_to_file as pil_image_to_file
from typing import Any, Callable

__all__ = ['content_type_media', 'content_type_service', 'update_types', 'WorkerThread', 'AsyncTask', 'CustomRequestResponse', 'async_dec', 'deprecated', 'is_bytes', 'is_string', 'is_dict', 'is_pil_image', 'chunks', 'generate_random_token', 'pil_image_to_file', 'is_command', 'extract_command', 'extract_arguments', 'split_string', 'smart_split', 'escape', 'user_link', 'quick_markup', 'antiflood', 'parse_web_app_data', 'validate_web_app_data', 'or_set', 'or_clear', 'orify', 'OrEvent', 'per_thread', 'webhook_google_functions']

content_type_media: Incomplete
content_type_service: Incomplete
update_types: Incomplete

class WorkerThread(threading.Thread):
    count: int
    queue: Incomplete
    daemon: bool
    received_task_event: Incomplete
    done_event: Incomplete
    exception_event: Incomplete
    continue_event: Incomplete
    exception_callback: Incomplete
    exception_info: Incomplete
    def __init__(self, exception_callback: Incomplete | None = None, queue: Incomplete | None = None, name: Incomplete | None = None) -> None: ...
    def run(self) -> None: ...
    def put(self, task, *args, **kwargs) -> None: ...
    def raise_exceptions(self) -> None: ...
    def clear_exceptions(self) -> None: ...
    def stop(self) -> None: ...

class ThreadPool:
    telebot: Incomplete
    tasks: Incomplete
    workers: Incomplete
    num_threads: Incomplete
    exception_event: Incomplete
    exception_info: Incomplete
    def __init__(self, telebot, num_threads: int = 2) -> None: ...
    def put(self, func, *args, **kwargs) -> None: ...
    def on_exception(self, worker_thread, exc_info) -> None: ...
    def raise_exceptions(self) -> None: ...
    def clear_exceptions(self) -> None: ...
    def close(self) -> None: ...

class AsyncTask:
    target: Incomplete
    args: Incomplete
    kwargs: Incomplete
    done: bool
    thread: Incomplete
    def __init__(self, target, *args, **kwargs) -> None: ...
    def wait(self): ...

class CustomRequestResponse:
    status_code: Incomplete
    text: Incomplete
    reason: Incomplete
    def __init__(self, json_text, status_code: int = 200, reason: str = '') -> None: ...
    def json(self): ...

def async_dec(): ...
def is_command(text: str) -> bool: ...
def extract_command(text: str) -> str | None: ...
def extract_arguments(text: str) -> None: ...
def split_string(text: str, chars_per_string: int) -> list[str]: ...
def smart_split(text: str, chars_per_string: int = ...) -> list[str]: ...
def escape(text: str) -> str | None: ...
def user_link(user: types.User, include_id: bool = False) -> str: ...
def quick_markup(values: dict[str, dict[str, Any]], row_width: int = 2) -> types.InlineKeyboardMarkup: ...
def or_set(self) -> None: ...
def or_clear(self) -> None: ...
def orify(e, changed_callback): ...
def OrEvent(*events): ...
def per_thread(key, construct_value, reset: bool = False): ...
def deprecated(warn: bool = True, alternative: Callable | None = None, deprecation_text: Incomplete | None = None): ...
def webhook_google_functions(bot, request): ...
def antiflood(function: Callable, *args, number_retries: int = 5, **kwargs): ...
def parse_web_app_data(token: str, raw_init_data: str): ...
def validate_web_app_data(token: str, raw_init_data: str): ...
